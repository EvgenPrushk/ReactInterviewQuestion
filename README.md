# 1. Что такое React?

Это билблиотека JavaScript c открытым исходным кодом, созданная facebook для
разработки сложных интерактивных пользовательских интерфейсов в веб и мобильных
приложениях. Основаная цель React - создание компонентов пользовательского интефейса,
их часто называют "V" ("View") в архитектуре "MVC". Прогандирует конпонентный подход

## 2. Что такое Виртуальная DOM?

Виртуальны DOM является претавлением реального DOM в памяти. React создает структуры
данных в памятиб вычисляет результирующие различия и затем эффективно обновляет
отображаему DOM браузера. Это позволяет программисту писать код, как будто вся страница
отображается при каждом изменении, в то же время как библиотека React отображает только
те компонеты, которые действительно изменяются. Очень крутая оптимизация.

## 3. В чем разница между состоянием и свойством?

И своства и состояния являются простыми объектами JS. Хотя обо они содержат информацию,
которая влияет на результаты рендеринга, они различаются по отношению к компонету:

- Свойство аналогично параметрам функции;

- Состояние управляется внутри компонета аналогично переменным, объявленным внутри функции

## 4. Какие существуют фазы жизненного цикла компонентов React?

Существует 4 различных  этапа жизненного цикла компанента React:

- Иницализация. На этом этапе компонет React готовит установку начального состояния и
  параметров по умолчанию

- Монтирование. Компонет React готов для монтировани в DOM браузера. Этот этап охватывает
  методы жизненного цикла componentWillMount =>renderM<= componentDidMount 

- Обновление. На этом этапе компоненты обновляются двумя способами, отправляя новые свойства и
  обновляя состояния. Этот этап охватывает методы жизненного цикла shouldcomponentUpdate
  componentWillUpdate, componentDidUpdate

- Размантирование. На последнем этапе компонент не нужен и отключается из DOM браузера.
  Этот включает метод жизненного цикла componentDidUnmount

## 5. Как работает React?

React запускает виртуальны DOM. Когда состояние изменяется в копонете, он сначала запускает
алгоритм различий, который определяет, что изменилось в виртуальном DOM. Вторым этапом
является согласование, при котором обновляется DOM с рузультами сравнения отличий.

## 6. Что такое JSX?

JSX является расширением синтексиса JavaScript и поставляется с полной функциональностью
JS. JSX производит элементы React. Вы можете встроить любое выражем JS в JSX, заключив его в
круглые скобки. После компиляции выражения JSX становяться обычными объектами JavaScript. Это
означает, что вы можете использовать JSX внутри операторов if и циклов for, назначать его
переменным, принимать его в качестве аргументов и возвращать из функции.

## 7. Что такое потомки?

В выражениях JSX, которые содержать закрывающие и открывающие теги, содежимое между тегами
передается в компонеты автоматически в качестве специального свойства {props.children}. В React
API есть несколько методов для работы с этими объектом. К ним относяться React.Сhildren.map,
React.children.forEach, React.children.count, React.children.only, React.children.toAray

## 8. Что такое состояние в React?

Состояние похоже на свойства, но оно является частным и полностью компонентом. State = это обязательно объект, который содержит данные и определяет, как компонет отображается и ведет себя

## 9. Что такое контролируемые компоненты?

В HTML элементы формы, такие как input, textarea и select, как правило поддерживают свое собственное состояние и обновляют его на основе пользовательского ввода. Когда пользователь отправляет форму, значение из этих элементов, значение из этих элементов, упомянутых выше отправляются вместе с формой. В React это работает по другому. Компонент, содержащий форму, будет отслеживать значение ввода в своем состоянии и повторно визуализировать компонент каждый раз, когда вызывается функция обратного вызова onChange, например, при обнавлении состояния. Элементы ввода формы, значение которого контролирует React, называются контролируемыми компонентами.

## 10. Что такое Flux?

Flux - это парадигма разработки приложения, используемая в качестве замены более традиционного шаблона MVC. Это не фреймворк или библиотека, а новый тип архитектуры, который дополняет React и концепцию однонаправленного потока данных. Facebook использовал этот шаблон при работе над React для создания рабочего процесса между компонентами диспатчера, хранилища и представлениями с различными входами и выходами следующим образом.

## 11. Что такое Redux?

React  по своей сути инструмент для визуализации. Redux - это библиотека, которая позволяет работать с потоком данных отдельно от приложения. И с помощью react-redux мы связываем модель данных и отображение. Один объект для состояния всего приложения. Redux - это контейнер с предсказуемым состоянием для JS, основанный на шаблоне проектирования Flux.Redux может использоваться вместе с ReactJS или любой другой библиотекой представлений. Он очень компактный (около 2КБ) и не имеет никаких зависимостей.

## 12. Как изменяется состояние в Redux?

Единственный способ изменить состояние - это создать действие,объект, описывающий произошедшее. Это гарантирует, что ни представления, ни сетевые обратные вызовы никогда не будут выполнять запись напрямую в состояние. Поскольку все изменения централизованы и происходят одно за другим в строгом порядке, не существует существенных условий конкуренции. Поскольку действия просто обычными объектам, их можно регистрировать, сериализироват, хранить и затем вопспроизводить для целей отладки и тестирования.

## 13. Что такое «store» в Redux?

Хранилище - это объект, которое хранит состояние приложения и предоставляет несколько спомогательных методов для доступа к состоянию, отправки действий и регистрации прослушивателей( getState - изменять состояние) Все состояние представлено одним хранилище. Любое действие возвращает новое состояние через редукторы. Это делает Redux очень простым и предсказуемым.

## 14. Что такое чистая функция?

В компьютерном программировании чистая функция = это функция, котораяимеет следующие свойства:

- Ее возвращаемое значение одинаково для тех же аргументов(без изменений с локальными статическими переменными, нелокальными переменными, изменяемыми ссылочными аргументами или входными потоками с устройств ввода-вывода)

- ее оценка не имеет побочных эффектов( нет мутации локльных статических переменных, нелокальных переменных, изменяемых ссылочных аргументов или потоков ввода-вывода). Таким образом, чистая функция вычисляется аналогично математической функции.

## 15. Как бы вы отключили хранилище Redux, чтобы оно не принимало никаких изменений в состоянии?

Один из способов сделать это - установить для флага exit в редукторе корневого состояния значение true, просто оставляя состояние неизменным

## 16. Почему Мы Должны Использовать ReactJS?

- Virtual DOM вместо реального DOM

- Быстротa и масштабируемость

- JSX предоставляет код, который легко читать и писать

- React JS это библиотека, которая легко интегрируется с другими JavaScript фреймворками

- Легко писать юнит тесты

## 17. Может Ли Веб-Браузеры Читать JSX?

Нет, не могут. Для преобразования необходима использовать конвектор

## 18. В Чём Различие Между React JS и React Native?

- самостоятельная платформа

- не используется html разметка, а используются компоненеты

- готовый bangle собирает сервер.

- более грамоздкие приложения

- ограниченный функционал

## 19.Какие есть ограничения в React?

- Это библиотека (часть решений он не поддерживает из коробки)

- Требуется время на освоение

- Не самая простая архитектура и инфраструктура

## 20. Что такое Props(свойства)?

Существуют для передачи свойст от родителя к дочернему элементу и рендеринга компонента

## 21. Что такое state и как он используется?

Это объект, который содержит определенные состояния, он является мутабельным. И отрисовывает интерфейс

```javascript
 constructor(props) {
super(props)

    this.state = {
        isOpen: false,
        youtubeChannel: 'EvgenPrushak'
    }

}
```

## 21. Что такое state и как он Ref?

Это означает в переводе с ангийского, что мы можем создавать ссылки на DOM элемент. Данный функционал нам нужен для создания фокуса на элемент, когда мы хотим выделить текст, когда мы хотим взаимодействовать с анимацией или взаимодействие со сторонними библиотеками(как вариант взаимодействие с DOM)

```javascript
class Mycomponent extends React.Component {
  constructor(props) {
    super(props);
    this.input = React.createRef();
  }

  render() {
    return <input type="text" ref={this.inputRef} />;
  }

  componentDidMount() {
    this.inputRef.current.focus();
  }
}
```

## 22. Что такое JEST?

Предназначен для юнит тестирования. Разработчиком JEST является компания Facebook и основан на фреймворке JASMIN.

## 23. Когда стоит использовать классовые компоненты, а когда функциональные?

Если у Вас компонент используется для отрисовки интерфейса, то его следует делать функциональным (т.к. он потребляет меньше ресурсов). Но если у Вас компонент со сложным доступом ( например жизненные этапы компанентов), то его стоит сделать классовым.

## 24. Что происходит, когда вы вызываете setState?

В первую очередь React получает тот объект, которые мы передаем в функцию setState и соединяет его(merge) со стейтом, который был. Как результат мы болучаем новый стейт, на основе которого React создает новый виртуальный DOM. Затем идет сравнение виртуального и реального DOM. Найдя различия, он изменяет только места, где есть различия. Одним словом setState позволяет максимально эффективно взаимодействоавть с интерфейсом.

## 25. В чем разница между state и props?

state - это структура данных, который имеет начальные значения и для отрисовки React использует начальное значение state. state может менять и как правило это происходит из-за пользовательских действий. props - это параметры, которые поступают в компанент (от родителя). Эти параметры не изменяемые, однонаправленное состояние, которое передается по древавидной структуре.

## 26. Когда стоит делать асинхронные запросы на сервер?

- componentDidMount(). Если ответ с сервера придет до того, как html готов, то могут произойти ошибки

## 27. В чем смысл специального атрибута key?

1. Без key механизм reconciliation сверяет компоненты попарно между текущим и новым VDOM. Из-за этого может происходить большое количество лишних перерисовок интерфейса, что замедляет работу приложения.
2. Добавляя key, вы помогаете механизму reconciliation тем, что с key он сверяет не попарно, а ищет компоненты с тем же key (тег / имя компонента при этом учитывается) — это уменьшает количество перерисовок интерфейса. Обновлены/добавлены будут только те элементы, которые были изменены/не встречались в предыдущем дереве.
3. Следите, чтобы не появлялись дублирующие key, при переключении отображения у новых данных не совпадали ключи. Это может привести к нежелательным сайд-эффектам, таким как анимации, или некорректной логике поведения элемента.
4. В редких случаях key используют и для одного элемента. Это сокращает размер кода и упрощает понимание. Но область применения этого подхода ограничена.
5. key и ref — специальные props. Они недоступны в компоненте, их нет в child.props. Можно получить доступ в родителе через child.key, но реальных областей применения для этого практически нет. Если в дочерних компонентах нужен key — правильным решением будет задублировать в prop id, например.

## 28. Что значит компонент mounted?

Это значит, что наш компонент вмонтирован в DOM дерево (html) и компонент готов к работе

## 29. Назовите разницу между контролируемыми и не контролируемыми компонентамии?

Контролируемый компонет, это компонет в котором есть state, за которым мы следим. (например input)
На каждое измение инпута мы вызываем функцию setState или используем hook. В неконтролиремом компоненте так же есть state, но мы его необрабатывает (контролирем). Например textarea

## 30. Что такое фрагменты ?

Бывают силуации, когда нам неоюходимо отрендерить text и мы не хотим, чтобы у данного шаблона был корневой элемент. И по сути не создается родительский элемент, тем самым облегчается html. Второй вариант создания фрагмента <></>. При создании родительского элемента через фрагмент, он будет пустым

```javascript
render() {
    return(
        <React.Fragment>
        Some text
        <h2>A heading</h2>
        </React.Fragment>
    )
}
```

## 31. Как реакт обрабатывает пользовательские события?

Для того, чтобы оптимировать работу React добавляет одно событие для корневого элемента(хотя в приложении может быть много кликов). Когда иы получаем объект событие (event). React нам предлагает свой специальный class SyntheticEvent. Который представляет собой обертку, которая позволяет работать в старых браузерах. В результате мы получаем общий API,который можем использовать.

## 32. В компонент setState можно передавать объект или функцию. В чем разница и что лучше использовать?

По умолчанию передается объект. Но мы может передавать и функцию, которая принимает в себя предыдущее состостояние мы формируем новое состояние. Дело в том, что props и state в React работают асинхронно. И когда в метод setState Вы передаете объект, то это не гарантрует Вам, что Вы будете работать с предыдущим состоянием. Вот по этой причине для работы с предыдущим состоянием мы будем передвать функцию.

## 33. В чем разница между презентационным компонентом и контейнер компонентом?

По сути презентационные компонты - это компоненты, которые говорят нам, как должно все выглядеть и на основании props рисуют нам интерфейс. Контейнер компонеты говорят нам, как все должно работать и взаимодействовать. В них содержится информацию по state, поведению и обычно он раздает различне свойства.

## 34. Что такое Context?

Специальный метод,  в которым мы передаем начальные состояние и в итоги мы получаем специальный объект context. И дальше мы можем использовать объект context не совсем по обычному при этом мы можем использовать или Provider или Consumer. В React может быть большая вложенность и для передачи на некоторый уровень вложенности использует context. Через контекст мы можем передвать состояния, функции на нужный нам уровень вложенности.
```javascript
const Mycontext = React.createContext(defaultValue);
<Mycontext.Provider value={/* some value */}> 
<Mycontext.Consumer>
{value => /* render something based on the context value*/}
</Mycontext.Consumer>
```

## 35. Что такое Higher-Order компоненты?

Это такие конструкции, которые как input принимают component и добавляют к нему какой-то функционал(возможности) и на выходе мы получает новый компонент с расширенными возможностями

## 36. Что делает shoudComponentUpdate и почему он важен?

Данный метод служит для оптимизациии render  React. И он отвечает на вопрос: Нужен ли нам процесс render сейчас или его можно избежать. По результаты мы получать значение try or false. Если false= то рендеринг не будет происходить. Например нам приходит state и он не влияет на отображение, то мы просим React не делать перерендеринг. В React присутствует class pure component, который реализует shoudComponentUpdate или если мы используем функциональные компонты, то react memo.

## 37. Что делает shoudComponentUpdate и почему он важен?

JavaScript объект, в котором содержится состояние приложения. Дополнительно
отвечает за следующее:

- state может быть получен через getState()

- Изменять state можно через dispatch(action)

- Регистрировать изменения через subscribe(listener)

## 38. Что нельзя делать в методе render?

Нельзя изменять состояние компонента (например вызывать setState). Должен быть
чистой (pure) функцией

## 39. Что такое action в Redux?

Объект, который обязательно должен содержать ключ type. С помощью него Redux
понимает, что именно нужно сделать со стейтом

## 40. Какие типы middleware есть в redux для работы с асинхронностью?

- Redux Thunk
- Redux Promise
- Redux Saga

## 41. Что такое Pure Components?

Тоже самое, что и Component, кроме того, что автоматически за вас реализует метод
shouldComponentUpdate.

## 42. Почему не стоит изменять state напрямую?

Не будет запущен процесс ре-рендеринга и интерфейс не поменяется. Корректно
использовать метод setState().

## 43.  Как изменить state используя динамический ключ?

```javascript
inutChangeHandler(event) {
    this.setState({
        [event.target.name]: event.target.value;
    })
}
```

## 44. Что такое Error Boundaries в React?

React - компонент, позволяющий обрабатывать ошибки в дочерних компонентах. Для
это присутствует метод componentDidCatch(error, info)

## 45.  Что такое React Hooks?

Функционал, добавленный в React 16.8. С помощью хуков, можно писать приложения,
используя только функциональные компоненты, без классов.
С помощью хуков можно следить за стейтом, эмулировать жизненные этапы
компонента, работа с ссылками и многое другое

## 46.   В чем разница между useRef и createRef?

- createRef - всегда создает новую ссылку. Используется в class компонентах
- useRef - возвращает одинаковую ссылку на объект, которое были при
начальном рендеринге

## 47.   Что такое useState?

Встроенные React хук. Позволяет работать со стейтом в функциональных
компонентах. Принимает начальное значение. Возвращает массив, состоящий всегда
из 2х элементов (кортеж), где:
● первый элемент - само состояние
● второй элемент - функция, меняющая состояние

## 48. Что такое prop drilling и как этого избежать?

Передача свойств на прямую от родителя к ребенку через сложную и длинную
иерархию компонентов.
Избежать можно используя Context или например Redux (Flux)

## 49. Как валидировать props в React?

Для этого есть дополнительная библиотека - PropTypes

## 50. Зачем делать eject?

На случай, если необходимо модифицировать конфигурацию проекта (webpack, babel)

## 51. Разница между Flux и MVC?

MVC (model view controller) - парадигма, разделяющая отображение и данные, однако
присутствуют следующие минусы:
● каскадная модель данных, сложно отслеживать состояние
● данные могут быть изменены где угодно. Как следствие непредсказуемое
поведение UI
Flux позволяет решить проблему каскадной модели данных. Данные получаются из
отдельного store и менять напрямую их нельзя.

## 52. Что не так с этим кодом?

```javascript
this.setState((prevState, props) =>{
  return {
    counter: PrevState.counter + props.counter
  }
}
```
С этим кодом все хорошо. Изменяем state на основе прошлого состояния и входящих
параметров

## 53. Какой второй опциональный параметр можно передать в метод setState и за что он отвечает?

Функция, уведомляющая, что компонент закончил процесс ре-рендеринга

## 54. Что такое mapStateToProps и mapDispatchToProps?

Функции в Redux, позволяющие приводить к более удобному формату данные из store
в компонент

## 55. Что такое React Fiber?

Fiber - это новый механизм и базовый алгоритм для рендеринга в React 16. Основная
цель - реализовать пошаговый рендеринг виртуального DOM для более быстрого
рендеринга, работы с анимациями и дебагом

## 56. Разница между Flow и PropTypes?

● Flow - статический инструмент для проверки типов. Использует аннотации и
позволяет найти ошибки при компиляции (аналог TypeScript)

● PropTypes - проверяет типы входящих параметров в runtime

## 57. Правда ли, что React делает ре-рендер всех компонентов и дочерних компонентов каждый раз когда вызывается setState?

По умолчанию - да. Однако мы этим можем управлять в
shouldComponentUpdate(nextProps, nextState)

## 58. Как можно улучшить производительность React Redux приложения?

По умолчанию - да. Однако мы этим можем управлять в
shouldComponentUpdate(nextProps, nextState)

Избавиться от лишних рендеров (самой затратной операции).
Для этого можно использовать:

1. shouldComponentUpdate в класс компонентах
2. PureComponent для класс компонентов
3. React.memo() - для функциональных компонентов

## 59. Зачем нужен Redux Thunk?

Middleware позволяющая изменять состояние приложения в Redux в асинхронном
режиме

## 60. В чем ключевое отличие между React и Angular?

React - библиотека для отрисовки приложения. Для другого функционала нужны
другие решения (например для данных - Redux)
Angular - обширный фреймворк, где все решения есть в ядре (в коробке)
● Используя React - можно более гибко создавать приложения и более точечно
управлять его частями
● Используя Angular - проще разрабатывать и поддерживать приложения

## 61. Перечислите некоторые ситуации, в которых следует использовать ссылки?

Ниже приведены ситуации, в которых следует использовать ссылки:

Необходимо управлять фокусом, выбирать текст или воспроизведение мультимедиа
Запускаемая анимация
интегрировать со сторонними библиотеками DOM

### JavaScript

## 62. Типы данных в JavaScript?

1. 7  Примитивных типов данных: Boolean, string, number, , bigInt, sumbol,null, undefined.
2. Не приммитивный тип данных: Object.

## 63.   Приведение типов в JavaScript?

```javascript
console.log(1+'2'); // string 12
console.log("+1+0) //1
console.log("-1+0) //-1
console.log('3'*'8') //24
console.log(4+10 +'px') //14px
console.log('px'+ 5+10 +) //px510
console.log('42'- 40 +) //2
console.log('42px'- 2 ) //NaN
console.log(null + 2) //2
console.log(undefined+ 41) //NaN  т.к. undefined  не приводиться к числу

 // == vs ===  (== сравнивает по значению с приведения типов, === без приведения типов)
console.log(2 == '2'); // true
console.log(2 === '2'); // false
console.log(undefined == null); // true
console.log(undefined === null); // false
console.log('0' == false); // true
console.log('0' == 0); // true
console.log('0' === 0); // false
console.log('0' === false); // false

// Неодназначные сравнения
https://dorey.github.io/JavaScript-Equality-Table/
console.log(false == ''); // true
console.log(false == []); // true
console.log(false == {}); // false т.к  объект приводиться к строке 'object object'
console.log('' == 0); // true
console.log('' == []); // true
console.log('' == {}); // false
console.log(0 == null) //false
```

## 64 .   Отсортировать массив чисел?

```javascript
const array= [1,25, 55,77, -5,108]
array.sort((a,b)=> {return a -b}));
```

## 64 .   Перебирающие методы массива?

1. Map -  возвращает новый массив не изменяя исходный,  выполняя действия над  каждым элементом массива
2. filter
3. .forEach
4. .reduce
Arrray.prototype.myMap = function(callback){
const result=[]
const theisArray = this
for(let i= 0; i< theisArray.length; i++){
result.push(callback(theisArray[i], i, theisArray))

}
return result
}

## 65 .   Управляемые и не управляемые компоненты?

```javascript
 const [state, setState]= useState()
 const input2 =useRef();
 const click =() =>{
 console.log(state)
 console.log(input2.current.values)
 }
 return(
 <div>
 <input onchange={(event)=> setState(event.target.value))  placeholder='Управляемый'/>
   <input ref={input2}  placeholder='Не управляемый'/>
  <button onClick={click}>Get Value </button>
   </div>
 )
```
 
 ## 65 .   Что ввела ЕS6?
 
1. Введены let  и const
2. Объект можно делать const.
3. Диструктуризаци объекта или массива.
4. Итераторы  for of   для перебора элементов массива.
5. Итераторы  for of   для перебора и разбиение строки по символьно.
6. ``  для переноса строк.
7. В функцию можно передавать значение по умаолчанию
8. Диструктуризация в функциях
9. Стрелочные функции.
10. Мультилайн  string \n.
11. Наследование с помощью   super и extends.

 ## 66 .   Что ввела ЕS7?
 
1. Array.includes() - содержит ли массив значение  или массив значений.
2. Math.pow() - оператор возведения в степень

 ## 67.   Что ввела ЕS8?
 
 1. String — padStart() и padEnd()
    
```javascript
const str = 'test'.padStart(10)
const str1 = 'test'.padEnd(10,'*')

console.log(`'${str}'`) //'      test'
console.log(`'${str1}'`) //'test******'
```

3. Object.values()
   
```javascript
const person = { name: 'Fred', age: 87 }
const personValues = Object.values(person) 
console.log(personValues) // ['Fred', 87]
```
 4. Метод Object.entries()
     
 ```javascript
const person = { name: 'Fred', age: 87 }
const personValues = Object.entries(person) 
console.log(personValues) // [['name', 'Fred'], ['age', 87]]
```

 5.Object.getOwnPropertyDescriptors(obj) -он принимает объект, сведения о свойствах которого нужно узнать, и возвращает объект, содержащий эти сведения.
Один из вариантов сделать копию объекта и копирует геттеры и сеттеры в отличиие Object.assign()

```javascript
const person = { name: 'Fred', age: 87 }
const propDescr = Object.getOwnPropertyDescriptors(person)
console.log(propDescr) 
/*
{ name:
   { value: 'Fred',
     writable: true,
     enumerable: true,
     configurable: true },
  age:
   { value: 87,
     writable: true,
     enumerable: true,
     configurable: true } }
```

6. Завершающие запятые в параметрах функций
7. Асинхронные функции 
В стандарте ES2017 появилась конструкция async/await, которую можно считать важнейшим новшеством этой версии языка.

Асинхронные функции представляют собой комбинацию промисов и генераторов, они упрощают конструкции, для описания которых раньше требовался большой объём шаблонного кода и неудобные в работе цепочки промисов. Фактически, речь идёт о высокоуровневой абстракции над промисами.

Когда в стандарте ES2015 появились промисы, они призваны были решить существующие проблемы с асинхронным кодом, что они и сделали. Но за те два года, которые разделяют стандарты ES2015 и ES2017, стало ясно, что промисы нельзя считать окончательным решением этих проблем.

В частности, промисы были нацелены на решение проблемы «ада коллбэков», но, решив эту проблему, они сами показали себя не с лучшей стороны из-за усложнения кода, в котором они используются. Собственно говоря, конструкция async/await решает проблему промисов и повышает удобство работы с асинхронным кодом.

```javascript
function doSomethingAsync() {
  return new Promise((resolve) => {
      setTimeout(() => resolve('I did something'), 3000)
  })
}
async function doSomething() {
  console.log(await doSomethingAsync())
}
console.log('Before')
doSomething()
console.log('After')
```

Как видно, после вызова doSomething() программа продолжает выполняться, после Before в консоль тут же выводится After, а после того, как пройдут три секунды, выводится I did something.

8. Последовательный вызов асинхронных функций
При необходимости асинхронные функции могут формировать нечто вроде цепочек вызовов. Такие конструкции отличаются лучшей читабельностью, чем нечто подобное, основанное исключительно на промисах. Это можно видеть на следующем примере.

```javascript
function promiseToDoSomething() {
  return new Promise((resolve)=>{
      setTimeout(() => resolve('I did something'), 10000)
  })
}
async function watchOverSomeoneDoingSomething() {
  const something = await promiseToDoSomething()
  return something + ' and I watched'
Здесь речь идёт об объекте SharedArrayBuffer, который позволяет описывать разделяемые области памяти, и об объекте Atomics, который содержит набор атомарных операций в виде статических методов. Подробности о возможностях, которые дают программисту эти объекты, можно почитать здесь.
async function watchOverSomeoneWatchingSomeoneDoingSomething() {
  const something = await watchOverSomeoneDoingSomething()
  return something + ' and I watched as well'
}
watchOverSomeoneWatchingSomeoneDoingSomething().then((res) => {
  console.log(res) // I did something and I watched and I watched as well
})
```
9. Разделяемая память и атомарные операции    
Здесь речь идёт об объекте SharedArrayBuffer, который позволяет описывать разделяемые области памяти, и об объекте Atomics, который содержит набор атомарных операций в виде статических методов. Подробности о возможностях, которые дают программисту эти объекты, можно почитать здесь.

 ## 68.   Что ввела то ввела ЕS9?
 
 1. Применение операторов spread и rest к объектам
 Мы уже говорили об операторах rest и spread, которые появились в ES6 и могут быть использованы для работы с массивами. Оба они выглядят как три точки. Оператор rest, в следующем примере деструктурирования массива, позволяет поместить его первый и второй элементы в константы first и second, а все остальные — в константу others.

 ```javascript
const numbers = [1, 2, 3, 4, 5]
const [first, second, ...others] = numbers
console.log(first) //1
console.log(second) //2
console.log(others) //[ 3, 4, 5 ]
```

Оператор spread позволяет передавать массивы в функции, ожидающие обычные списки параметров.

 ```javascript
const numbers = [1, 2, 3, 4, 5]
const sum = (a, b, c, d, e) => a + b + c + d + e
const res = sum(...numbers)
console.log(res) //15
```

Теперь, используя тот же подход, можно работать и с объектами. Вот пример использования оператора rest в операции деструктурирующего присваивания.

 ```javascript
const { first, second, ...others } = 
  { first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }
console.log(first) //1
console.log(second) //2
console.log(others) //{ third: 3, fourth: 4, fifth: 5 }
```

Вот оператор spread, применяемый при создании нового объекта на основе существующего. Этот пример продолжает предыдущий.

 ```javascript
const items = { first, second, ...others }
console.log(items) //{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }
```

2.Асинхронные итераторы

Новая конструкция for-await-of позволяет вызывать асинхронные функции, возвращающие промисы, в циклах. Такие циклы ожидают разрешения промиса перед переходом к следующему шагу. Вот как это выглядит.
 
 ```javascript
for await (const line of readLines(filePath)) {
  console.log(line)
}
```

3. Метод Promise.prototype.finally()
Если промис успешно разрешается — осуществляется вызов очередного метода then(). Если что-то идёт не так — вызывается метод catch(). Метод finally() позволяет выполнять некий код независимо от того, что происходило до этого.
 
 ```javascript
fetch('file.json')
  .then(data => data.json())
  .catch(error => console.error(error))
  .finally(() => console.log('finished'))
```

4. Улучшения регулярных выражений
В регулярных выражениях появилась возможность ретроспективной проверки строк (?<=). Это позволяет искать в строках некие конструкции, перед которыми есть какие-то другие конструкции.

Возможность опережающих проверок, использующая конструкцию ?=, имелась в регулярных выражениях, реализованных в JavaScript, и до стандарта ES2018. Такие проверки позволяют узнать, следует ли за неким фрагментом строки другой фрагмент.
 
 ```javascript
const r = /Roger(?= Waters)/
const res1 = r.test('Roger is my dog')
const res2 = r.test('Roger is my dog and Roger Waters is a famous musician')
console.log(res1) //false
console.log(res2) //true
```

Конструкция ?! выполняет обратную операцию — совпадение будет найдено только в том случае, если за заданной строкой не идёт другая строка.
 
 ```javascript
const r = /Roger(?! Waters)/g
const res1 = r.test('Roger is my dog')
const res2 = r.test('Roger is my dog and Roger Waters is a famous musician')
console.log(res1) //true
console.log(res2) //false
```

При ретроспективной проверке, как уже было сказано, используется конструкция ?<=.
 
 ```javascript
const r = /(?<=Roger) Waters/
const res1 = r.test('Pink Waters is my dog')
const res2 = r.test('Roger is my dog and Roger Waters is a famous musician')
console.log(res1) //false
console.log(res2) //true
```

Операцию, обратную описанной, можно выполнить с помощью конструкции ?<!.
 
 ```javascript
const r = /(?<!Roger) Waters/
const res1 = r.test('Pink Waters is my dog')
const res2 = r.test('Roger is my dog and Roger Waters is a famous musician')
console.log(res1) //true
console.log(res2) //false
```

Управляющие последовательности Unicode в регулярных выражениях
В регулярных выражениях можно использовать класс \d, соответствующий любой цифре, класс \s, соответствующий любому пробельному символу, класс \w, который соответствует любому буквенно-цифровому символу, и так далее. Возможность, о которой идёт речь, расширяет набор классов, которыми можно пользоваться в регулярных выражениях, позволяя работать с Unicode-последовательностями. Речь идёт о классе \p{} и об обратном ему классе \P{}.

В Unicode каждый символ имеет набор свойств. Эти свойства указываются в фигурных скобках группы \p{}. Так, например, свойство Script определяет семейство языков, к которому принадлежит символ, свойство ASCII, логическое, принимает значение true для ASCII-символов, и так далее. Например, выясним, содержат ли некие строки исключительно ASCII-символы.

 ## 68.   Что ввела то ввела ЕS10?
 
 1. Array.flat() и Array.flatMap()
 Метод Array.flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно подняты на указанный уровень depth.
Метод Array.flatMap() сначала применяет функцию к каждому элементу, а затем преобразует полученный результат в плоскую структуру и помещает в новый массив. Это идентично функции map() с последующим применением функции flat() с параметром depth, равным 1, но flatMap() чаще более эффективен, поскольку совмещает в себе оба подхода в одном методе.

2. String.trimStart() & String.trimEnd()
могут быть использованы для обрезки пробелов в начале или в конце строки.
 
 ```javascript
const greeting = "    Hello everyone";
console.log(greeting.trimStart());
// "Hello everyone"
```

 ```javascript
const greeting = "Hello world    ";
console.log(greeting.trimEnd());
// "Hello world"
```

3. Необязательная привязка catch
 
 ```javascript
try {
  // some code
} catch {
  // error handling code
}
```
4. Object.fromEntries()
Object.fromEntries() создает объект или преобразует пары ключ-значение в объект. Он принимает только итерации: Object.fromEntries(someIterable).
 ```javascript
const students = new Map([
  ["name", "john"],
  ["age", 22],
]);

console.log(Object.fromEntries(students));
// { name: 'john', age: 22 }

const students = [
  ["john", 22],
  ["alex", 22],
  ["julia", 21],
  ["alex", 20],
];

Сценарий, который приводит к потери данных:

const studentObj = Object.fromEntries(students);
// { john: 22, alex: 20, julia: 21 }
// первый alex был перезаписан
```
5. Symbol.description
Свойство description только для чтения - это строка, возвращающая необязательное описание объектов Symbol.
 ```javascript
const mySymbol = `My Symbol`;

const symObj = Symbol(mySymbol);

console.log(symObj); // Symbol(mySymbol);

console.log(String(symObj) === `Symbol(${mySymbol})`); // true

console.log(symObj.description); // "My Symbol"
```
6. Хорошо сформированный JSON.stringify()
Исправленный вывод JSON.stringify() при обработке суррогатных кодовых точек UTF-8 (от U+D800 до U+DFFF).

Перед этим изменением вызов JSON.stringify() возвращал некорректный символ Unicode («�»).

Теперь эти суррогатные кодовые точки можно безопасно представить в виде строк, используя JSON.stringify(), и преобразовать обратно в их исходное представление, используя JSON.parse().
 ```javascript
JSON.stringify('\uD800');
> '"�"'

JSON.stringify('\uD800');
> '"\\ud800"'
```
7. toString()
Function.prototype.toString(). Функции всегда имели метод экземпляра toString(), который возвращает строку, содержащую код функции.

ES2019 ввел изменение в возвращаемое значение, чтобы избежать удаления комментариев и других символов, таких как пробел, точно представляющих функцию в том виде, как она была определена.


 ## 69.   Что ввела то ввела ЕS11?
 
 ## String#matchAll
  matchAll - это новый метод, добавленный к прототипу String, который связан с регулярными выражениями. Он возвращает итератор, который в свою очередь возвращает все совпадающие группы одну за другой.
   ```javascript
const str = "abc";
const regexp = /[a-c]/g;
const iterator = str.matchAll(regexp);

for (result of iterator) {
  console.log(result);
}
// ["a", index: 0, input: "abc", groups: undefined]
// ["b", index: 1, input: "abc", groups: undefined]
// ["c", index: 2, input: "abc", groups: undefined]
```

## Dynamic import

 ## BigInt

Одна из самых ожидаемых функций в JavaScript, и она наконец-то здесь. BigInt это встроенный объект, который предоставляет способ представлять целые числа больше pow(2, 53) - 1, наибольшего числа, которое JavaScript может надежно представить с Number примитивом.

На данный момент максимальное число, которое можно хранить как целое число в JavaScript, равно pow(2, 53) - 1. BigInt позволяет пойти дальше.

Тем не менее, нужно добавить n в конце числа. n означает, что это BigInt.
   ```javascript
let oldMax = Number.MAX_SAFE_INTEGER; // 9007199254740991
++oldMax; // 9007199254740992
++oldMax; // 9007199254740992 <- такое же значение

let newMax = 9007199254740992n;
++newMax; // 9007199254740993n
++newMax; // 9007199254740994n

const a = 9007199254740991n; // 9007199254740991n
const b = BigInt(9007199254740991n); // 9007199254740991n
a === b; // true

typeof 10; // "number";
typeof 10n; // "bigint";
```
 ## Promise.allSettled
Помнишь функцию Promise.all? Он выполнялся успешно (resolves) только тогда, когда все переданные промисы были выполнены успешно. И выполнялся с ошибкой (rejects), если хотя бы один из промисов был отклонен, в то время как другие ещё могли быть в статусе ожидания (pending).

Новый allSettled ведет себя иначе. Он выполняется всякий раз, когда все промисы заканчиваются, то есть выполнились успешно или выполнились с ошибкой. Он возвращает массив, который содержит как статус промиса, так и значение (или ошибку).

Таким образом, allSettled никогда не отклоняется. Он либо в состоянии ожидания, либо выполнился успешно.
   ```javascript
const promiseArray = [
  Promise.resolve(200),
  Promise.reject(""),
  Promise.reject(new Error("Error")),
];

Promise.allSettled(promiseArray).then((result) => {
  console.log("All Promises Settled", result);
});

// All Promises Settled
// [
//   {status: "fulfilled", value: 200},
//   {status: "rejected", reason: ""},
//   {status: "rejected", reason: Error: Error at <anonymous>:4:18}
// ]
```
 ## globalThis
В JavaScript всегда есть один большой объект контекста, который содержит всё. Традиционно в браузерах это window. Но если попытаешься получить к нему доступ в Node, то получишь ошибку. В Node нет глобального объекта window; вместо этого есть объект global. С другой стороны, в WebWorkers нет доступа к window, но вместо этого есть self.

ES2020 приносит globalThis, который всегда ссылается на глобальный объект, независимо от того, где мы выполняем свой код:
   ```javascript
// Прежде, решение было таким:

const getGlobal = function () {
  if (typeof self !== undefined) {
    return self;
  }
  if (typeof window !== undefined) {
    return window;
  }
  if (typeof global !== undefined) {
    return global;
  }
  throw new Error("unable to locate global object");
};

const globals = getGlobal();

// Сейчас есть `globalThis`
globalThis === window; // true
```

 ## for-in mechanics
Спецификация ECMA не указывала, в каком порядке for (x in y) должно выполняться. Несмотря на то, что браузеры реализовали согласованный порядок самостоятельно, это официально стандартизировано в ES2020.

- Optional chaining
Новый оператор опциональной последовательности призван сделать код короче, при работе со вложенными объектами и проверкой на undefined.
   ```javascript
const car = {};
const color = car?.color;
const colorName = car?.color?.name;
```

 ## Nullish coalescing
Nullish coalescing - добавляет возможность действительно проверять нулевые (nullish) значения вместо ложных (falsey). В чем разница между значениями nullish и falsey?

В JavaScript многие значения ложные falsey. Например: пустые строки, число 0, undefined, null, false, NaN и т. Д.

Тем не менее, во многих случаях нам нужно проверить, является ли переменная нулевой то есть - undefined или null; например, когда переменная может иметь пустую строку или даже значение false.

В этом случае мы можем использовать новый оператор ??
   ```javascript
const myVar2 = initialValue ?? 10; // 0
```

 ## Module namespace exports
В JavaScript модулях уже можно было использовать следующий синтаксис:
   ```javascript
import * as utils from "./utils.mjs";
Тем не менее до сих пор, не было никакого синтаксиса экспорта:
export * as utils from "./utils.mjs";
Он эквивалентен следующему:
import * as utils from "./utils.mjs";
export { utils };
```
 ## 70.   Что ввела то ввела ЕS12?
 ## Метод String replaceAll()
 String.prototype.replaceAll() заменяет все вхождения строки другим строковым значением.
 
 ## WeakRef
 В JavaScript есть автоматический процесс сборки мусора. Он может собирать только недоступные объекты. Каждый раз, когда мы делаем присваивание объекту, то создаем сильную ссылку. Это защищает его от сборки мусора.
 WeakRef может принимать объект только в качестве аргумента.
   ```javascript
function Foo() {}

// сильная ссылка на экземпляр Foo
const x = new Foo();

// слабая ссылка на экземпляр Foo
const xWeak = new WeakRef(x);
```
Почему это полезно? Это позволяет повысить производительность приложения в зависимости от устройства пользователя. Мы можем использовать WeakRefs для кеширования больших объектов. Это означает, что машины с большим объемом памяти могут увидеть увеличение производительности приложения. Те, у кого ограниченная память, по-прежнему будут работать, не съедая память пользователя.

JavaScript - это язык со сборкой мусора. Ты можешь узнать больше о сборщике мусора JavaScript здесь, на сайте MDN.

## Финализаторы

Финализаторы - еще одна функция ES12 в области памяти. Эта функция сообщает нам, когда объект был собран сборщиком мусора. Это делается с помощью обратного вызова (callback) JavaScript.

Однако следует помнить о нескольких вещах:

не гарантируется, что обратный вызов будет выполнен;
целевой объект уже очищен и недоступен;
длительность выполнения обратного вызова, не является детерминированным. Это может быть как одна минута, так и один час.
eakRef может принимать объект только в качестве аргумента.
   ```javascript
// построение метода финализатора
const registry = new FinalizationRegistry((value) => {
  // код очистки должен быть здесь
  console.log(value);
});
```
registry является экземпляром FinalizationRegistry. Функция обратного вызова, переданная в FinalizationRegistry, срабатывает, когда объект собирается сборщиком мусора.
   ```javascript
// построение метода финализатора
const registry = new FinalizationRegistry((value) => {
  // код очистки должен быть здесь
  console.log(value);
});
```
(function () {
  const obj = {};
  // подключаем переменную `obj` к финализатору
  registry.register(obj, "Deleted");
})();
На 3-й строке мы подключаем объект к registry. Когда сборщик мусора забирает obj, второй аргумент метода .register() передается функции обратного вызова. Итак, согласно логике нашего кода, когда obj забирается сборщиком мусора, строка "Deleted" передается функции обратного вызова и печатается в консоль.

Когда ты выполнишь приведенный выше код в консоли Google Chrome, примерно через 1 минуту он напечатает "Deleted". Еще один способ принудительно выполнить сборку мусора в Chrome - щелкнуть значок Collect Garbage. Ты можешь найти его во вкладке Performance.

## Promise.any() и AggregateError
Есть еще одна полезная утилита - новый метод Promise.any. В качестве аргумента он принимает повторяющиеся промисы. Когда любое из них выполнено, он вызовет обратный вызов (callback) параметра Promise.any() или вернет ответ. Это зависит от того, используешь ли ты async/await или нет.

Когда все промисы терпят неудачу - метод выдаст ошибку AggregateError, которая объединяет все различные ошибки промисов. Почему бы не вернуть простой массив? В основном для совместимости. Это будет экземпляр ошибки, и ты получишь трассировку стека. Хорошо иметь эту информацию на случай, если она понадобится.


   ```javascript
Promise.any([
  Promise.reject("Error 1"),
  Promise.reject("Error 2"),
  Promise.resolve("success"),
]).then((result) => {
  console.log("result:", result);
});
// result: success
```
Использование синтаксиса async/await:

   ```javascript
(async () => {
  const result = await Promise.any([
    Promise.reject("Error 1"),
    Promise.reject("Error 2"),
    Promise.resolve("success"),
  ]);
  console.log(`result: ${result}`);
})();
// result: success
```
Теперь давай проверим пример сценария ошибки. В этом случае Promise.any() генерирует исключение AggregateError. Нам нужно поймать и справиться с этим.
   ```javascript
try {
  (async function () {
    const result = await Promise.any([Promise.reject("Error 1")]);
    console.log(`result: ${result}`);
  })();
} catch (error) {
  console.log(error.errors);
}
```
В демонстрационных целях в Promise.any() передается только одно обещание. И этот промис завершается «с ошибкой» (reject). Приведенный выше код регистрирует следующую ошибку в консоли. И это четвертое дополнение к прототипу Promise.

Итак, давай подведем итог! В настоящее время в нашем распоряжении имеется следующее:
## Оператор логического присваивания
Наконец, эти новые спецификации ES12 поставляются с долгожданными операторами. Новые операторы объединяют оператор логического присваивания с логическими операциями &&, || и ??.

x &&= y;
x ||= y;
x ||= y;
   ```javascript
let x = 5;
const y = 10;
x &&= y;

console.log(x);
// 10

let x = 5;
const y = 10;
x ||= y;

console.log(x);
// result is 5

let x;
const y = 10;
x ??= y;

console.log(x);
// result is 10

```
## Подчеркивание как числовой разделитель
  ```javascript
const oneMillion = 1_000_000;
console.log(oneMillion); // 1000000

```
Typescript
function map<T, R>(arr: T[], function(v: T, i: number, arr: T[])=>R): T
## Оптимизация
1. Лишние  рерандеры ( особенно в списках). ReactMemo
2.  Не очищают  SetTimout, listner.
3.   Lasy loading.
4.   Подгрузка списка по частям.
5.   Профилировщик.
6.   Огромный бандл ( разделять на чанки и загружать по страницам).
7.   Next js.
8.   Загрузка в фоне.

 ## 71. Async and defer
 Defer -    не отрисовывает страницу, пока не загрузиться файл.
 Async -   не останавливает загрузку страницу, а потом уже грузит файл.
 
 ## 72 В чем разница между классами и хуками
 1. Вынуждены были писать хоки. Было псевдонаследование. Одни элементы оборачивались в другие и усложняла код.
 2. Дерево приложения простое.
 3. Быстрая выполнение по сравнению с классовыми компанентами, кроме рендеринга анимации.
 4. Код стало писать легче и понятней.
 5. Есть проблема ререндера.
 6. Сложно анализировать код с наследованием и что обнавлять.
 
  ## 72 State в react, что нельзя делать
  1. Мутировать  state.
  2. У нас  идет поверхностное сравнение  dom дерева, а не глубокое.
  
  ## 73 Гетеры и сетеры позволяют контролировать  state
  1. Использование гетеров и сетеров позволяет  меньше памяти.
  2.  Колличество ререндеров   меньше   rerender.
  
  Оптимизация рендера 
  
  ##74 Что делает ReactMemo 
  1. Первым аргументом принимает компонент, вторым функцию. Сравнить пропсы старые и новые и понять необходимо ли обнавлять компонент.
  
  ##75 Что делает useMemo?
   
   Функция обарачивается в  useMemo  и при одних и тех же зависимостях возвращает  то же резульатат.
   
   ##76 Для чего нужен useLayoutEffect?
   
   Аналогичен по своей функциональности с useEffect, но  он запускается синхронно после всех изменений DOM дерева, перед тем, как браузер получит шанс осуществить отрисовку. Предпочитайте стандартный useEffect, когда это возможно, чтобы избежать блокировки визуальных обновлений(необходимо получить данные перед отрисовкой, подгрузка стилей). Но он может тормозить загрузку.
   
 ## 77.  Принудительный  update
  ```javascript
const Component = ()=>{
const [isUpdated, setIsUpdated] =useState(false);
const  isUpdatdeRef = useRef(false);

const  forceUpdate = useCallback(()=> {
isUpdated.current = !isUpdatdeRef.current
setIsUpdated(isUpdatdeRef.current);
},[])

return <div></div>
```

   ## 78.  Какой компонент нельзя  реализовать на хуках ErrorBoundary (предохранители)   
   Ранее ошибки JavaScript внутри компонентов портили внутреннее состояние React и заставляли его выдавать таинственные сообщения об ошибках во время следующего рендера. Эти сообщения всегда вызывались ошибками, расположенными где-то выше в коде приложения, но React не предоставлял способа адекватно обрабатывать их в компонентах и не мог обработать их самостоятельно.

   ## 79.  Написать  map через  reduce.
  ```javascript
   function map(arr, mapper){
   
   retun arr.reduce((acc, cur, i, orignalArr)=>{
  acc.push(mapper(curr, i, orignalArr));
   
   return acc;
   }, []);
   }
 ``` 
   ## 80.  Написать  filter через  reduce.
   
  ```javascript
   function map(arr, predicate){
   
   retun arr.reduce((acc, cur, i, orignalArr)=>{
    const isAdded = predicate(curr, i , orignalArr);
    if(isAdded){
    acc.push(curr)
    }
   
   return acc;
   }, []);
   }
 ```     

   ## 81.  Написать  функцию каррирования
   
   ```javascript
function curry( func, length = function.length){
return (...args) =>{
  if(args.length < length) {  
  return curry(
  (..otherArgs)=> func(...args, ...otherArgs),
 length - args.length
  );
}
return func(...args)
}
``` 
  ## 82.   UseContext
  
   Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве.
   
  ## 83.   useReducer
  
        Альтернатива для useState. Принимает редюсер типа (state, action) => newState и возвращает текущее состояние в паре с методом dispatch. (Если вы знакомы с Redux, вы уже знаете, как это работает.)
        Хук useReducer обычно предпочтительнее useState, когда у вас сложная логика состояния, которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего. useReducer также позволяет оптимизировать производительность компонентов, которые запускают глубокие обновления, поскольку вы можете передавать dispatch вместо колбэков.
          const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
  );
  
  ## 84.  useCallback
  
       Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров (например, shouldComponentUpdate).

       
  ## 85.  useMemo
  
       Возвращает мемоизированное значение.

useRef возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.

Обычный случай использования — это доступ к потомку в императивном стиле:
  ```javascript
function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` указывает на смонтированный элемент `input`
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
    </>
  );
}
 ```  
 
 Это возможно, поскольку useRef() создаёт обычный JavaScript-объект. Единственная разница между useRef() и просто созданием самого объекта {current: ...} — это то, что хук useRef даст один и тот же объект с рефом при каждом рендере.
 
   ## 87.  useImperativeHandle
   
   useImperativeHandle настраивает значение экземпляра, которое предоставляется родительским компонентам при использовании ref. Как всегда, в большинстве случаев следует избегать императивного кода, использующего ссылки. useImperativeHandle должен использоваться с forwardRef:
   ```javascript
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} ... />;
}
FancyInput = forwardRef(FancyInput);
 ```   
 
  ## 88.  useDebugValue
    
   useDebugValue может использоваться для отображения метки для пользовательских хуков в React DevTools.
   
  ## 89.  useDebugValue
  
    useDebugValue может использоваться для отображения метки для пользовательских хуков в React DevTools.
    
  ## 90.  useDeferredValue
  
принимает значение и возвращает новую копию значения, которая будет отложена до более срочных обновлений. Если текущий рендеринг является результатом срочного обновления, например, ввода пользователя, React вернет предыдущее значение, а затем отобразит новое значение после завершения срочного рендеринга.

  ## 91.  useTransition
  
  Возвращает значение состояния для отложенного состояния перехода и функцию для его запуска.

startTransitionпозволяет помечать обновления в предоставленном обратном вызове как переходы:

  ## 91.  useId
  
  useId— это ловушка для создания уникальных идентификаторов, которые стабильны на сервере и клиенте, избегая при этом несоответствий гидратации.  
         
  ## 92. Замыкание
      
      Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась. Это говорит о том, что замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение.
      
   ## 93. Что такое цикл событий (event loop) и как он работает?
   
      Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.

Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.

Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.  
  
   ## 94. Что такое прототип объекта в JavaScript?
  
  Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном выступает специальное свойство __proto__

Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-.

К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.

При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.

Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person.
  
 ## 95. Как работает ключевое слово this?
   
   Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply
В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.
Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.
      
  ## 96.  Promise?
   
   Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
   
## 97.  Как работают методы apply(), call() и bind()?
   
   Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.

Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this - методы bind, call и apply.

Синтаксис метода call: func.call(context, arg1, arg2, ...)

При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).

Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.

func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);

Синтаксис встроенного bind: var wrapper = func.bind(context, [arg1, arg2...])

Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

## 98. Что такое Set, Map, WeakSet и WeakMap?
Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:

 ## 99. Что такое ООП?
 Абстракция — отделение концепции от ее экземпляра;
Полиморфизм — реализация задач одной и той же идеи разными способами;
Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

 ## 100. Уязвимости сайтов?
 - XSS (Cross-Site Scripting или межсайтовый скриптинг, Js-иньекция) ( у нас в  html  документ вставляется вредоносный код, который дает возможность получить данные пользователя). Чтобы предотвратить необходимо использовать санитаризацию ( DOM Purify), и настраивать Content-Security-Policy(CSP) Header. C каким  origin’ом  они могут запускаться на странице.
 - CSS Injection  (внедрение вредоносного файла стилей в проект).  Защита  style-src Content Security Policy
 - CSRF (Cross Site Request Forgery или межсайтовая подделка запроса ). Для каждой сессии использовать свой ключ и использовать токет  (CSRF-токен) 
 -  Vulnerable & outdated components (уязвимые или неподдерживаемые компоненты) – библиотеки и утилиты. Проверка кода устанавливаемой библиотеки и использование  SNYK.
 -  Unvalidated redirects & forwards – невалидные перенаправления, случаются в старых браузерах
 
 ## 101. В чем отличие объекта от класса?
 Класса, это описание как будет существовать твой объект.
 
 ## 102. Что такое  Solid;
 S - принцип единственной отвественности ( отвечает за что-то одно, за музыкую котиков и т.д.)
 O - open, close   открыт  для расширения и закрыт для изменения ( используем mui кнопку, изменять кнопку нельзя, а  добавлять новый функционал можно)
 L - принцип подстановки барбары Лисоков( если у нас кнопка унаследована от  mui,  то она не должна ломать функционал при подстановке
 I-  инверсия зависимости ( в  TypeScript  имеется  interface  и в нем есть методы, которые  данная сущность не использует). По этому  стоит создать интерфейсы, которые использует  все методы, а если  есть другой User (Admin,  например), то стоит унаследоваться от Юзера и расшить добполнительными методами
 D- решение о том, какой из компонентов будет использован в каждом случае, должен принимать вызывающий код
## 104 Что такое  REST API
  Формат взаимодействия sever-  клиент   или  sever/server. На сервере находиться набо ручек (endpoint)  делаю запрос к которым можно получать,  создавать, редактировать данные. Чаще всего подруземавает взаимодествия по HTTP. Сотоит из за header, body  и строки запроса ( url адрес). Get, PUЕ, PATCH, DELETE, OPTIONS  и т.д. В  хедер мы посылаем (  token,  content type,  длительность жизни кук).  В  body  мы передаем данные обычно при созданиие или редактирование объекта.
  
    ## 105  Какие способы защиты данные вы знаете
    Есть два основных способа защиты данные сессии и авторизация по токену. Есть база данных в которой мы храним сессии каждого пользователя и в куках мы получаем информацию идентифицирующую пользователя и с помощью куков мы можем ее проверить. Вторым способом является авторизация по токену  или uauc   протокол. Чаще всего используется  jwt token. Мы вводим логин и пароль и отправляем токет, дальше сервер создает пару токинов (refrech token  для перезаписи  аксесс токен, а с помощью аксесс токена мы получаем доступ к ресурсу ( роли, id, идентификацию).
    ##  106 Какую проблему решает React
    Сосредоточиться на работе с данными, а не с дом деревом( оптимизирующие механизмы,  удобное  api  для работы с состоянием, а не следить  за DOM  деревом.
     ##  107 Какую   сделать бесконечный scroll
     1. Привязываться к скролу страницы и подгружать данные.
     2. Использоваться  интершексен API  и отслеживать, когда часть интефейса попадает в видимую зону браузера. И с помощью патерна  observer  и к
   когда невидимый блок попадает в зону видимости окна браузера мы выполняем действия по подгрузке.
      3. Исключить множественные запросы.
      4. При длительной  загрузке большой объем данных и памяти требуется, чтобы исключить это можно использовать виртуальный  scroll. (  который   рендерить  только видимую часть и скрывает не видимые(чистыми).
       
       ##  107 Event Bus
       Нужен для того, чтобы   компонентам не связанным друг с другом можно передавать те или иные события.
       
       ## 108 Какие библиотеки используются для анимации
       1. СSS-анимация
        2. React Spring.
        3.React Animations
        4. React Move   
        5. Frame Motion 
        6.React Transition Group
        
        ##  109 Способы взаимодействия клиента и сервера
        1. WebSocket обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов. WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.
        2. Long polling  – это самый простой способ поддерживать постоянное соединение с сервером, не используя при этом никаких специфических протоколов (типа WebSocket или Server Sent Events).Его очень легко реализовать, и он хорошо подходит для многих задач.Самый простой способ получать новую информацию от сервера – периодический опрос. То есть, регулярные запросы на сервер вида: «Привет, я здесь, у вас есть какая-нибудь информация для меня?». Например, раз в 10 секунд.В ответ сервер, во-первых, помечает у себя, что клиент онлайн, а во-вторых посылает весь пакет сообщений, накопившихся к данному моменту.Это работает, но есть и недостатки: Сообщения передаются с задержкой до 10 секунд (между запросами). Даже если сообщений нет, сервер «атакуется» запросами каждые 10 секунд, даже если пользователь переключился куда-нибудь или спит. С точки зрения производительности, это довольно большая нагрузка.
        3. Polling  – опрос на появление обновлений каждые n секунд.
        
  ##  110 Как получить ссылку на элекмент формы,  которая содержит пароль
        1. document.getelementbyid.
        2. document.queryselector.
        3. document.getElementsByTagName => inputs[i].type.toLowerCase() === "password"
        3.if (document.querySelectorAll)
        return document.querySelectorAll("input[type='password']"); 

        ##  111 При  https соединении шифруются ли куки?
        1. Есть только  определенный набор куков, которые не шифруются. Чтобы обеспечивать безопастность и поэтому токены безопастно передавать.

        ##  112 При  можно ли в  get    запрсе передавать данные?
        1. У  get  запроса  нет   body   и данные  передаются в   query  параметрах(которые видны всем),  что не секьюрно.

        ##  113  Найти пересечения двух массивов со сложностью O(n)
  ```javascript
  function findIntersection(arr1, arr2) {
  const intersection = [];
  const map = {};

  // Создаем хэш-таблицу для элементов первого массива
  for (let i = 0; i < arr1.length; i++) {
    map[arr1[i]] = true;
  }

  // Проверяем каждый элемент второго массива на наличие в хэш-таблице
  for (let i = 0; i < arr2.length; i++) {
    if (map[arr2[i]]) {
      intersection.push(arr2[i]);
      // Удаляем элемент из хэш-таблицы, чтобы избежать дублирования
      delete map[arr2[i]];
    }
  }

  return intersection;
}
 ```
##  114 Отличие Map  от объекта
1. Работает быстрее, из-за  меньшей функциональной нагрузки

##  114 Разница микротасок от максотасок.
1. В Микротаси попадают промиссы
   

   
        
      
        
        
        

        
  
        


  
       
      
    
