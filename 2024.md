# 1. Как рендериться html в браузере?
1. Html код преобразуется в DOM дерево
2. Загружаются и парсятся сss стили (css может блокировать загрузку) 
3. Формируется css OM дерево
4. Если встречается js скрипт, то он может заблокировать рендеринг.(async, defer чтобы избежать)
5. Формируется на основаве ом дерева DOM дерево рендер tree(дерево объектов рендера)
6. На основе рендер tree их положение, ширина, высота  и тд. (стадия layout)
7. Отрисовка(стадия paiding)
8. Стадия composition (группировка элементов по слоям и выносит вычисления в отдельный слой. Что бы они выполнялись на стороне видеокарты)
## 2. Как принудительно вынести html элемент на слой?
Есть свойство @layer
## 3. В чем бьудет разница  измения элемента в через top, left и через transform, translate?
Рекомендуется использовать свойства transform и translate, которые вызывают только операции composition (используют GPU). Свойства left и right вызывают более ресурсоемкие операции reflow и repaint (используют CPU)
## 4. В чем отличие тега 'img' и 'picture'?
1. Picture позвволяет задать разные изображения для условий (размер экрана, формат).
2. Picture позволяет задать несколько форматов изображения, а img только один.
3. Picture позволяет задать несколько изображений, а img только один.
4. Picture позволяет выбирать браузеру изображение, которое лучше всего подходит, а img только один.
## 5.Для чего нужен семантика?
1. Улучшение читаемости кода.
2. Доступ для людей с ограниченными возможностями.
3. SEO оптимизация.
4. Логическая структура документа.
5. Cоотвествие стандартам и улучшения поддержки браузерами.
## 6. Что такое мексины?
Мексины - это функция, с  аргументом или без. Для того, чтобы не дублировать стили
## 7. Что такое %(название) класса (сайлент-классы" или placeholder-классы)?
Они используется для создания шаблона стилей и не попадают в итоговый bundle. И используются другими стилями через директиву @extend. И быстрее миксинов.
## 8. Чем отличается работа диретивы import от директивы use css?
import использует весь файл, а use только  переменные которые ты используешь.
## 9. Чем отличается работа диретивы import от директивы use css?
import использует весь файл, а use только  переменные которые ты используешь.
## 10. Какие  utility types есть в typescript?
1. Partial<Type>- создает тип, где все свойства  становяться не обязательными.
2. Required<Type>- создает тип, где все свойства типа становяться обязательными.
3. Readonly<Type>- создает тип, где все свойства типа становяться только для чтения.
4. Record<Keys, Type>- создает объект, из типа - ключи,  а значения должны быть типа указанного во втором параметре.
5. Pick<Type, Keys>- создает новый  тип, который содержит только указанные свойства из типа.
6. Omit<Type, Keys>- создает новый  тип, исключаая указанные свойства из типа.
7. Exclude<Type, ExcludedUnion>- создает тип, исключая из объединения типов указанные ExcludedUnion (во втором параметре).
8. Extract<Type, Union>- создает тип, содержащий только те типы, которые присутствуют в Union (во втором параметре).
9. ReturnType<Type>- создает тип, который возвращается из функции.
10. InstanceType<Type>- создает тип, который возвращается из конструктора.
11. NonNullable<Type>- создает тип, который исключает null и undefined из типа.
12. Parameters<Type>- создает тип, который содержит параметры функции.
13. ConstructorParameters<Type>- создает тип, который содержит параметры конструктора.
14. ThisParameterType<Type>- создает тип, который содержит тип this для функции.
15. OmitThisParameter<Type>- создает тип, который исключает this из типа.
16. ThisType<Type>- используется для обозначения.
17. Awaited<Type>- создает тип, который ожидает, что тип является асинхронным.
18. Uppercase<StringType>- создает тип, который преобразует все символы в строке в верхний регистр.
19. Lowercase<StringType>- создает тип, который преобразует все символы в строке в нижний регистр.
20. Capitalize<StringType>- создает тип, который преобразует первый символ в строке в верхний регистр.
21. Uncapitalize<StringType>- создает тип, который преобразует первый символ в строке в нижний регистр.
## 11. Какие  отличия от interfaces есть в typescript?
1. Type  используются для описания любых сущностей, а interfaces используются для описания объектов или классов (используя слова implements).
2. Типы могут расширяться с помощью пересечения типов &, а интерфейсы нет.
3. Интерфейсы могут наследоваться от других интерфейсов с помощью ключевого слова extends, а типы нет.
4. Интерфейсы могут исливаться при одинаковом имени.
5. Интерфейсы не могут быть использованы с примитиваими и объединениями, а типы могут.
## 12. Абстрактные классы в typescript?
1. Обстрактные классы объявляются с помощью ключевого слова abstract.
2. Обстрактные классы не могут быть созданы с помощью оператора new.
3. Обстрактные классы могут содержать абстрактные методы, которые должны быть реализованы в дочерних классах.
4. Обстрактные классы могут содержать неабстрактные методы, которые могут быть переопределены в дочерних классах. 
5. Обстрактные классы могут содержать свойства и методы, которые могут быть переопределены в дочерних классах.
6. Обстрактные классы могут создаваться с помощью методо init.
7. Прокинуть дженерик в абстрактный класс мы не можем (java может)
## 13. Если разница при работе между any и unknown?
1. При использование any отключается проверка типов.
2. unknown требует проверку типов перед использованием.
3. При сборке приложения с any, не будет ошибок, а при unknown будет, если нет проверки типов.
## 14. Что такое наследование в typescript?
Наследование это когда один класс наследует свойства и методы другого класса и родителя
## 15. В чем отличие proto от prototype?
1. proto - это ссылка на объект, который содержит свойства и методы. (есть у всех сущностей, кроме object.create(null))
2. prototype - это функция-конструктор, который содержит свойства и методы. (function declaration, function expression, class declaration, class expression)
## 17. Чем отличаетя итерация по ключам объекта for in и object.keys?
1. for in возвращает ключи объекта, а object.keys возвращает массив ключей.
2. for...in не гарантирует порядок ключей.
3. for...in  перебирает унаследованные свойства ( .hasOwnProperty(key) для того чтобы взять ключи самого объекта)
4. for...in перебирает свойства объекта любых типов, а object.keys перебирает только строковые ключи  объекты.
## 18. Что такое промисы?
1. Это обещание, которое необходимо для выполнения осинхронного кода.
2. Имеет 3 состояния: pending, fulfilled, rejected.
3. Можно условно сказать, что это функция конструктор( если  создано через new), которая принимает в себя функцию, которая принимает в себя 2 функции (resolve и reject).
4. Имеет методы then, catch, finally.
## 19. Какие статичекие методы есть у промисов?
1. Promise.all - принимает массив промисов и возвращает новый промис(если один промис откклонен, то все промисы отклонены).
```javascript
cont promise1 = Promise.resolve(3);
cont promise1 = Promise.resolve(10);
Promise.all([promise1, promise2]).then((values)=>{
  console.log(values);
}).catch((error)=>{console.log(error)});
```

2. Promise.allSettled -  возвращает промис, который выполнится, когда все промисы выполнятся или отклонятся.

```javascript
 const promise1 = Promise.reject('Ошибка 403');
 const promise2 = Promise.resolve(20);
 const promise3 = Promise.reject('Ошибка 404');
 
 Promise.any([promise1, promise2, promise3]).then((value)=>{
  console.log(value); //20
  [
  {status: 'rejected', value: ...объект ответа...},
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'rejected', reason: ...объект ошибки...}
]
 }).catch((error)=>{
  console.log(error); //Ошибка 403
 })
```

3. Promise.race - принимает массив промисов и возвращает первый промис, который выполнился или отклонился.

```javascript
 const promise1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, 'one');
 });
 const promise2 = new Promise((resolve,rejet)=>{
  setTimeout(resolve,100, 'two');
 })
 Promise.race([promise1, promise2]).then((value)=>{
  console.log(value); //two
 })
```

4. Promise.any - принимает массив промисов и возвращает первый промис, который выполнился, если все промисы отклонены, то возвращается ошибка.

```javascript
 const promise1 = Promise.reject('Ошибка 403');
 const promise2 = Promise.resolve(20);
 const promise3 = Promise.reject('Ошибка 404');
 
 Promise.any([promise1, promise2, promise3]).then((value)=>{
  console.log(value); //20
 }).catch((error)=>{
  console.log(error); //Ошибка 403
 })
```

5. Promise.reesolve - возвращает промис, который выполнился успешно.

```javascript
 const promise1 = Promise.resolve(20); 
```

6. Promise.reject - возвращает промис, который выполнился успешно.

```javascript
 const promise1 = Promise.resolve(20); 
```

## 20. Что такое async await?
1. Это синтаксический сахар для работы с промисами.
2. async функция всегда возвращает промис и можем ≥</StringType>использовать tлючпреждеевое слово await внутри нее.
3. await - подсказывает, что нужно дождаться выполнения промиса,  чем перейти к следующей строке кода.
4. для обработки ошибок используется try,catch, finally.
## 22. Какие хуки  имплиминтируют методы жизненного цикла в react?
1. componentDidMount (useLayoutEffect, useEffect(() => {}, []))
2. componentDidUpdate (useLayoutEffect, useEffect(() => {}, [dependencies]))
3. componentWillUnmount (useEffect(() => {
  return () => {
    // Действие при размонтировании
  };
}, []))
4. useLayoutEffect (getSnapshotBeforeUpdate).
## 23. Чем отличается useImperativeHandle от useRef ?
1. useRef - это ссылка на DOM элемент или React элемент.
2. useImperativeHandle - это ссылка на функцию.
## 24. Как принудительно перерисовать компонент?
1. использовать метод forceUpdate.
2. Метода useForceUpdate.
3. Метода useReducer.
4. используя useState для обновления состояния.
5. Измененить key.
6. Изменить Context  если компонент подписант на Сontext.
7. Изменить props.
8. Изменение родителя.
## 24. Для  чего нужны ключи в react?
1. React omit сопоставляет их при reconciliation.
2. Для оптимизации рендеринга.
## 25. Что такое  reconciliation?
1. Это механизм согласования. Когда у нас сравнивается виртиуальный DOM с его предыдущей версией. И вычисляется разница между ними. И потом эти изменения применяются к реальному DOM. (используется эвристический алгоритм(  на основе разных типов и ключей))
2. Для оптимизации рендеринга.
## 26. Что такое  reactFiber?
1. Это новая архитектура рендеринга, которая позволяет React разбить приложение на маленькие части, приоритизировать их и выолнять потепенно для поддержания плавности работы приложения
## 27. Разница между querySelector и между useRef?
1. useRef не вызывает повторных рендеров и сохраняет ссылку на элемент.
2. querySelector возвращает первый элемент, который соответствует заданному селектору.
3. querySelector может вызывать повторные рендеры и reconditioning.
## 28. Что такое React?
Это библиотека для создания пользовательских интерфейсов. Решает проблему манипуляций с реальным DOM деревом. Использует оптимизированную версию виртуальный DOM, reactFiber и  так далее. Позволяет избежать долних монипулций с  реальным DOM деревом. Компонентный подход и однонаправленный поток данных от родителя к ребенку.
## 29. Что такое Virtual DOM
Это копия реального DOM дерева, которая создается в памяти. И позволяет избежать долних монипулций с  реальным DOM деревом. Храниться он в виде объекта js. Поэтому мы можем его изменять без проблем с производительностью. И не затрагивать реальное DOM дерево. При измении состоянию сначалаобновляется Virtual DOM дерево. И потом сравнивается с предыдущей версией. И вычисляется разница между ними. И потом эти изменения применяются к реальному DOM. Потом он сравнивается с предыдущей версией. И вычисляется разница между ними. И потом эти изменения применяются к реальному DOM. (эврестический алгоритм)
## 30. Что такое эврестический алгоритм?
1. Если два элемента с разными тиами, то при сравнение дерево уничтожается и строиться новое.
2. Чтобы избежать перерисовок React использует их сапостовление, чтобы изюежать пересовок.
## 31. Почему плоохо использовать индексы в списке?
1. При добавлении или удалении элементов в списке, индексы не обновляются. (баги с состоянием)
2. Для улучшения лучге использовать уникальные id.
## 32. Что такое useEffect?
1. Это хук, который вызывается после монтирования компонента асинхронно. (тогда передаем пустой массив зависимостей).
2. В нем мы можем сайд эффекты, запросы на сервера, подпискок, манипуляции с DOM.
3. В нем мы можно вернуть клинап функцию, которая вызывается переж размонтировании компонента.
4. Или вызваться клинап со старыми значениями, а затем будет вызываться эффект снова.
## 33. Почему выбрал Redux плюс Redux-toolkit?
1. Имеются slice, которые позволяют создавать сложные приложения.
2. Удобно описывать async actions и обычные actions.
3. Автоматически встроен create async thunk.
## 34. Что ты знаешь про Сontext?
1. Позволяет создавать глобальное состояние без библиотек.
2. Помогает избежать передачи пропсов через все уровни компонентов(props drilling)
3. Нет поддержки  async actions.
4. Ререндариться все потребители контекста при его изменении(все что обернуто в Provider)
5. Нет поддержки  SSR(как вариант можно использовать библиотеку Next.js)
## 35. Как получить 10000 записей с  backend?
1. Добавить виртуализацию. 
2. Добавить пагинацию. (backend)
3. Добавить бесконечную прокрутку.
4. Добавить линию загрузки.
## 36. Что такое !DOCTYPE?
Позволяет указать какой тип будет  используется в документе. (html5)
## 37. В чем разница между  div и span?
1. div - это блок, который занимает всю ширину родителя.
2. span - это строчный элемент, который занимает только свою ширину.(inline).
## 38. В чем разница между между inline и inline-block?
1. inline - нельзя задать ширину и высоту через стили.
## 39. Как можно создать сетку на css?
1. Grid.
2. Flex.
3. Float
4. Position
5. Table
## 40. Расскажи про приоритет селекторов?
1. !important
2. inline стили (1)
3. id (0.1)
4. class, атрибуты и псевдоклассы (0.01)
5. tag и псевдоэлементы. (0.001)
## 41. Рвсскажи про свойство position?
1. static - статическое позиционирование(по умолчанию)
2. relative - относительное позиционированиe (относительно своего обычного положения)
3. absolute - абсолютное позиционирование (относительно родителя)
4. fixed - фиксированное позиционирование (относительно окна браузера)
5. sticky - фиксированное позиционирование (относительно родителя)
## 42. Как создать checkbox?
1. Создал span.
2. Обернуть span в label.
3. В label придумал id.
4. Обернуть в title, чтобы при клике изменял свое состояние.
5. Для галочки использовал псевдоэлементы :before и :after.
## 43. Расскажи про псевдоэлементы и псевдоклассы?
1. Псевдоэлементы: :before,  :after, ::first-letter, ::first-line, ::selection (создает контент и применяет стили)
2. Псевдоклассы: :hover, :active, :focus, :visited, :first-child, :last-child, :nth-child, :nth-last-child, :nth-of-type, :nth-last-of-type, :only-child, :only-of-type, :empty, :not, :target, :lang, :dir, :enabled, :disabled, :checked, :indeterminate, :valid, :invalid, :in-range, :out-of-range, :required, :optional, :read-only, :read-write, :placeholder-shown, :default, :required, :optional, :read-only, :read-write, :placeholder-shown, :default, :required, :optional, :read-only, :read-write, :placeholder-shown, :default, :required, :optional, :read-only, :read-write, :placeholder-shown, :default, :required, :optional, :read-only, :read-write, :placeholder-shown, :default, :required, :optional, :read-only (для изменения стилей в момент рендера)
## 44. Что тако Eveent Loop?
Бескоонечнфо цикл в котором выполняются  браузерные события. Они распределяются в очередь misrotask и macrotask. И позволляют выполнять асинхронный код без блокировки основного потока.
К микротаскам относятся:
1. Промисы.
2. функция queueMicrotask.
3. Метода process.nextTick.
4. Метода MutationObserver.
К макротаскам относятся:
1. setTimeout
2. setInterval
3. setImmediate.
4. requestAnimationFrame.
5. Ивенты.
Сначала выполняется весь синхронный код, затем все микротаски, затем берется одна макротаски.  Синхронный код попадает в call stack, выполняется и убирается из него. Асинхронный код попадает в webb api и обрабатывается, далее попадает  в callBack queue и далее попадает в call stack(только после того как call stack будет полностью очищен).
## 45. Что тако замыкание?
Является комбинацией функции и лексического окружения, в котором была определена эта функция. Это когда у нас есть вложенная и внешня функция. И внутренняя функция имеет доступ к переменным внешней функции даже после того как внешняя функция завершила свое выполнение. (с помощью рекурсии  реализуется инкапсуляция)
## 46. Xук useState ?
Позволяет работать с состоянием и создать локальное состояние. Принимает initialValue и возвращает тукущее состояние и callback функцию для изменения текущего значения. После каждого вызова setState происходит перерендер компонента
## 47. Xук useEffect ?
Позволяет выполнять side effect в функциональном компоненте (запросы, подписки). Вызывается асинхронно после того как браузер отрисовал компоненты. Вторым параметром принимает массив зависимостей. Если оставить его пустым, то эффект будет вызван при монтировании. Если передать элементы, то при их измении будет вызываться эффект. Если не передавать пустой массив, то эффект будет вызываться при каждом рендере. Так же в useEffect мы можем вернуть clineUp функцию, которая будет вызываться при размонтировании компонента или при изменении зависимостей.
## 48. Xук useRef?
Возвращает ref объект со свойством current. С помощью него мы можем поплучать доступ к DOM элементам. Не вызывает перерендер компонента. Мутирование свойства current не приводит к перерендеру компонента
## 49. Xук useContext?
Для того чтобы получить текущее значение контекста. И вызывается внутри компонента, который подписан на контекст. Изменение контекста приводит к перерендеру всех компонентов, которые подписаны на этот контекст
## 50. Xук useCallback?
Для мемоизации функций. Возвращает мемоизированную версию функции. Принимает функцию и массив зависимостей. Если массив зависимостей пустой, то функция будет вызываться только при монтировании компонента. Если массив зависимостей не пустой, то функция будет вызываться при изменении значения из массива зависимостей.
## 51. Xук useMemo?
Для мемоизации значений. Возвращает мемоизированное значение. Принимает функцию и массив зависимостей. Если массив зависимостей пустой, то функция будет вызываться только при монтировании компонента. Если массив зависимостей не пустой, то функция будет вызываться при изменении значения из массива зависимостей
## 52. useLayoutEffect?
Работает аналогично useEffect, но вызывается синхронно после того как браузер появились в виртуал DOM (но не были отрисованы браузером) и может блокировать отрисовку браузера
## 53. Расскажи про React.memo?
Сравнивает пропсы компонента с предыдущими пропсами и если они не изменились, то компонент не перерисовывается. Вторым аргументом принимает функцию сравнения пропсов. Если функция сравнения пропсов возвращает true, то компонент не перерисовывается. Если функция сравнения пропсов возвращает false, то компонент перерисовывается
## 54.  Когда стоит использовать useMemo и useCallback?
Их мы передает значения или функцию через props. И если эти значения или функции не изменяются, то мы можем использовать useMemo и useCallback.
## 55. Методы жизненного цикла классовых компонентов?
1. componentDidMount - вызывается после того как компонент был вмонтирован в DOM.
2. componentDidUpdate - вызывается после того как компонент был перерисован.
3. componentWillUnmount - вызывается перед тем как компонент будет удален из DOM.
4. shouldComponentUpdate - вызывается перед тем как компонент будет перерисован.
5. getDerivedStateFromProps - вызывается перед тем как компонент будет перерисован.
6. componentDidCatch - вызывается если в компоненте произошла ошибка.
## 56. Типы данных в JS?
1. Number
2. String
3. Boolean
4. Null
5. Undefined
6. Object
7. Symbol
8. BigInt
## 57. Что такое область видимости и какие бывают?
Область видимости - это место в которой мы можем обратиться к переменной или функции. Можно условино разделить на глобальную (из любого места в коде в переменной) , функциональную (в теле функцию ) и блочную (блок if). При создании локальной области видимости она запоминаетсяя во внешней области видимости и мы получаем цепочку областей видимости. И мы из одной области видимости можем обратиться к переменной из другой области видимости
## 58. Как работать с виртуализацией и мемоизацией?
1. Использовать useMemo и useCallback.
2. Использовать ключи.
3. Render видимых элементов.
4. Подгрузка элемнетов частями.
5. Использовать React.memo.
6. Lazy loading.
## 59. Разница между currentTarget и target?
1. currentTarget - это на котором прикреплен обработчик.
2. target - это элемент на котором произошло событие.
## 69. Декораторы в typescipt?
Декоратор - это функция, которая позволяет добавить дополнительную функциональность к классу, свойству, методу или параметру.
1. Классовые декораторы.
2. Декораторы свойств.
3. Декораторы методов.
4. Декораторы параметров.
5. Декораторы доступа.
## 62. Что такое оператор нелувого слияния?
если null  или undefined, то возвращается значение после ??, иначе возвращается значение до ??.
## 63. Основые паттерны Redux?
1. Flux - это паттерн, который позволяет создавать приложения с однонаправленным потоком данных, состояние только для чтения, и изменение состояния только через диспетчерс(создаем экшени отправляем его в диспетч=> у нас изменяется staete=> у нас изменяется интерфейс и так по кругу).
2. Command - в этом паттерне реализуемом через action  команда (action) инкапсулирует запрос на выполнение некоторой операции.
3. Observer - реализуется через подписку на измения состояния с метода subscribe.
4. Reducer - это часть патеерна Function Composition  ( который основывается на чистых функциях и композиции функций).
5. Middleware - это паттерн, который позволяет добавить дополнительную функциональность к приложению. И похож на Chain of Responsibility, промежуточное ПО передает действие следующему.
6. Container/Presenter (Контейнер/Презентер) -  контейнерные компоненты получают данные из store и передают их презентационным компонентам (view-компонентам), которые отвечают исключительно за отображение UI.
7. State Encapsulation (Инкапсуляция состояния) - компоненты не могу на прямую изменить состояния и сотяние храниться в одном месте(store)
8. Single Source of Truth (Единственный источник правды) - в приложении есть единственный источник правды, который хранится в store.
## 64. Где лучше хранить авторизационный токен?
В cookies. Используя флаг httpOnly и secure(передача только по https).
## 65. Cors ошибка?
1. Написать backend добавить в whitelist домен. ( в заголовке(header) список допустимых доменов)
2. Использовать whithCredentials: true.
3. Использовать proxy.
4. Отключить cors  политику в браузере через командную строку или плагин.
## 66. Чистота кода?
1. Eslint (bnb style guide)
2. Prettier
3. Husky 
4. Lint-staged
5. Commitlint
## 67. Откатить commit?
1. git reset --hard
2. git cherry-pick
3. git revert c  айди коммита
## 68. Что можно отслеживать с помощью media query?
1. Размер экрана(ширина и высота)
2. Ориентация экрана
3. Разрешение экрана
4. Поддержка touch
5. Поддержка hover
6. Поддержка ориентации
## 69. Чем отличаеются css  пермеменные нативные(--var) и в предпроцессоре($переменнная)?
1. Нативные переменные виднв в браузере,а переменные в предпроцессоре не видны в браузере.
## 70. Для чего нужные data-атрибуты?
1. Для хранения данных, которые не видны в браузере.
2. Для тестирования. 
## 71. Какие тиапы данных вернет reduce?
1. Любой тип данных.
## 72. Какие тиапы копирования масссивов?
1. Поверхностная копия. ([...arr], arr.slice(), [].concat(arr))
2. Полная копия или грубокая копия. (функцию lodash, через рекурсию, через JSON.parse(JSON.stringify(arr))(кроме function, undefined, Simbol, NaN, Infinity, -Infinity, RegExp, Date, Map, Set, WeakMap, WeakSet))
